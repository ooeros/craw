<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1">
  <title>ChatGPT Paste → Paged Reader v4.3.0 (Theme Builder)</title>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#a47a51"/>
  <style>
    :root{
      --bg: #f3ead7;
      --paper: #fcf7ec;
      --ink: #2a261f;
      --muted: #6f665a;
      --accent: #a47a51;
      --shadow: 0 10px 30px rgba(0,0,0,.08);
      --font: "Noto Serif KR","Noto Serif","Iowan Old Style","Palatino Linotype","Book Antiqua",Palatino,serif;
      --size: 20px;
      --lh: 1.8;
      --pageRadius: 18px;
      --maxw: 900px;
      --pad: 18px;
      --topPadExtra: 12px;
      --tapW: 44%;
      --anim: 160ms;
      --frameOn: 0;
      --autoGuard: 4px;

      /* v4.3.0 — texture variables */
      --paperTex: none;             /* e.g. url("blob:...") or none */
      --paperTexSize: 600px;        /* cover | contain | <len> */
      --paperTexRepeat: repeat;     /* repeat | no-repeat | round | space */
      --paperTexOpacity: .14;       /* 0 ~ 1 */
      --paperTexBlend: multiply;    /* multiply | overlay | soft-light | normal */

      --bgTex: none;                /* e.g. url("blob:...") or none */
      --bgTexSize: 800px;           /* cover | contain | <len> */
      --bgTexRepeat: repeat;        /* repeat | no-repeat | round | space */
      --bgTexOpacity: .08;
      --bgTexBlend: normal;

      /* v4.3.2 — extra paper texture controls */
      --paperTexPosX: 0px;
      --paperTexPosY: 0px;
      --paperTexRotate: 0deg;
      --paperTexFilter: none;

      /* optional second paper overlay */
      --paper2Tex: none;
      --paper2TexSize: 600px;
      --paper2TexRepeat: repeat;
      --paper2TexOpacity: .08;
      --paper2TexBlend: multiply;
      --paper2TexPosX: 0px;
      --paper2TexPosY: 0px;
      --paper2TexRotate: 0deg;
      --paper2TexFilter: none;
    }
    :root[data-theme="sepia"] { --bg:#f3ead7; --paper:#fcf7ec; --ink:#2a261f; --muted:#6f665a; --accent:#a47a51; --shadow:0 10px 30px rgba(0,0,0,.08); }
    :root[data-theme="paper"] { --bg:#ececec; --paper:#ffffff; --ink:#222; --muted:#666; --accent:#4d7c0f; --shadow:0 10px 30px rgba(0,0,0,.08); }
    :root[data-theme="solar"] { --bg:#fdf6e3; --paper:#fffdf5; --ink:#073642; --muted:#586e75; --accent:#b58900; --shadow:0 10px 30px rgba(0,0,0,.08); }
    :root[data-theme="slate"] { --bg:#e6ebf0; --paper:#f7f9fb; --ink:#0f172a; --muted:#475569; --accent:#2563eb; --shadow:0 10px 30px rgba(0,0,0,.06); }
    :root[data-theme="midnight"] { --bg:#0f1115; --paper:#14171d; --ink:#e5e7eb; --muted:#9aa4b2; --accent:#60a5fa; --shadow:0 12px 36px rgba(0,0,0,.35); }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; height: 100%;
      background: var(--bg); color: var(--ink);
      font-family: var(--font);
      font-size: var(--size);
      line-height: var(--lh);
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      -webkit-text-size-adjust: 100%;
    }
    .app { min-height: 100svh; display: grid; grid-template-rows: auto auto 1fr; }
    .topbar {
      position: relative; z-index: 1000;
      display: flex; align-items: center; gap: .5rem; flex-wrap: wrap;
      padding: .6rem clamp(10px, 3vw, 18px);
      padding-left: max(clamp(10px,3vw,18px), env(safe-area-inset-left));
      padding-right: max(clamp(10px,3vw,18px), env(safe-area-inset-right));
      background: color-mix(in srgb, var(--bg) 72%, #fff 28%);
      border-bottom: 1px solid #0001;
    }
    .topbar .title { font-weight: 700; letter-spacing: .2px; margin-right: auto; }
    .topbar button, .topbar select, .topbar input[type="range"], .topbar input[type="search"]{
      font-size: .9rem; border: 1px solid #0002; background: #ffffffe6;
      padding: .35rem .6rem; border-radius: 10px; cursor: pointer;
    }
    .topbar input[type="range"]{ width: 110px; }
    .topbar input[type="search"]{ width: 150px; }
    .editor-wrap { position: relative; z-index: 900; display: grid; gap: .5rem;
      padding: .6rem clamp(10px,3vw,18px);
      padding-left: max(clamp(10px,3vw,18px), env(safe-area-inset-left));
      padding-right: max(clamp(10px,3vw,18px), env(safe-area-inset-right));
      background: color-mix(in srgb, var(--bg) 85%, #fff 15%);
      border-bottom: 1px solid #0001; }
    .editor-wrap.collapsed { display: none; }
    .editor-wrap textarea { width: 100%; min-height: 34dvh; resize: vertical;
      padding: .9rem; background: var(--paper); border: 1px solid #00000018;
      border-radius: 14px; box-shadow: var(--shadow);
      font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;
      font-size: 15px; line-height: 1.6; color: #2a2a2a; }
    .editor-actions { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
    .primary { background: var(--accent); color: #fff; border: none; font-weight: 600; }
    .viewer { position: relative; z-index: 1; height: 100%; overflow: hidden;
      padding: 0 clamp(6px, 2.5vw, 12px) max(6px, env(safe-area-inset-bottom)); }
    /* background texture behind the page */
    .viewer::before{
      content:""; position:absolute; inset:0;
      background-image: var(--bgTex);
      background-size: var(--bgTexSize);
      background-repeat: var(--bgTexRepeat);
      opacity: var(--bgTexOpacity);
      mix-blend-mode: var(--bgTexBlend);
      pointer-events:none;
      z-index:0;
    }
    .stage { height: 100%; width: 100%; display: grid; place-items: center; position:relative; z-index:1; }
    .page {
      width: min(var(--maxw), 100%); height: 100%; background: var(--paper); color: var(--ink);
      border-radius: var(--pageRadius); box-shadow: var(--shadow);
      padding: calc(var(--pad) + var(--topPadExtra)) var(--pad) var(--pad) var(--pad);
      overflow: hidden; position: relative; display: none; touch-action: manipulation; }
    /* paper texture overlay */
    .page::after{
      content:""; position:absolute; inset:0; border-radius: inherit; pointer-events:none;
      background-image: var(--paperTex);
      background-size: var(--paperTexSize);
      background-repeat: var(--paperTexRepeat);
      opacity: var(--paperTexOpacity);
      mix-blend-mode: var(--paperTexBlend);
    }
    .page.current { display: block; }
    .page.measuring { display: block; visibility: hidden; position: absolute; left: -99999px; top: 0; }
    .content { height: 100%; overflow: clip; }
    .content-inner { min-height: 100%; padding-bottom: var(--autoGuard); }
    .page h1, .page h2, .page h3 { margin: .2rem 0 .6rem; line-height: 1.3; break-after: avoid; }
    .page h1 { font-size: 1.6em; } .page h2 { font-size: 1.28em; } .page h3 { font-size: 1.12em; }
    .page p { margin: 0 0 .95rem; text-wrap: pretty; }
    .page blockquote { margin: .8rem 0; padding: .4rem .8rem; background: #0000000a; border-left: 4px solid var(--accent); border-radius: 8px; }
    .page pre { background: #00000010; border: 1px solid #00000014; border-radius: 10px; padding: .6rem .8rem; white-space: pre-wrap; word-break: break-word; font-size: .9em; line-height: 1.55; }
    ul, ol { padding-left: 1.3rem; margin: 0 0 .8rem; }
    code { background: #00000012; padding: .1rem .3rem; border-radius: 6px; font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace; font-size: .92em; }
    .content-inner img { display:block; max-width:100%; height:auto; margin:.5rem auto; }
    .content-inner table { width:100%; border-collapse: collapse; margin:.6rem 0; background: #00000006; border:1px solid #0000001a; border-radius:10px; overflow:hidden; }
    .content-inner th, .content-inner td { border: 1px solid #00000014; padding: .45rem .5rem; font-size: .95em; }
    .content-inner thead th { background: #00000010; position: sticky; top: 0; }
    .tap { position: absolute; top: 0; bottom: 0; z-index: 5; }
    .tap.left { left: 0; width: var(--tapW); } .tap.right { right: 0; width: var(--tapW); }
    .tap.center { left: calc(var(--tapW)); right: calc(var(--tapW)); }
    .navbtn { position: absolute; top: 50%; transform: translateY(-50%); background: #ffffffcc; border: 1px solid #0001; border-radius: 999px; padding: .4rem .6rem; z-index: 6; user-select: none; display:none; }
    .ui-on .navbtn { display: inline-block; }
    .navbtn.left { left: 8px; } .navbtn.right { right: 8px; }
    .frame { position: absolute; inset: calc(var(--pad) + var(--topPadExtra)) var(--pad) var(--pad) var(--pad); border: calc(var(--frameOn) * 1px) solid #0002; border-radius: calc(var(--pageRadius) - 6px); pointer-events: none; }
    .hint { position: absolute; bottom: 8px; right: 12px; font-size: .9rem; color: var(--muted); background: #ffffffaa; padding: .12rem .5rem; border-radius: 8px; z-index: 4; display:none; }
    .footer { display:none; }
    .overlay { position: absolute; inset: 10px 12px auto; z-index: 8; display: none;
      background: color-mix(in srgb, var(--paper) 82%, #fff 18%);
      border:1px solid #0002; border-radius: 12px; padding:.4rem .6rem; box-shadow: var(--shadow);
      color: var(--ink); font-size:.95rem; }
    .overlay .row { display:flex; gap:.75rem; align-items:center; flex-wrap:wrap; }
    .overlay .bar { position: relative; width: 200px; height: 8px; background: #00000018; border-radius: 999px; overflow: hidden; }
    .overlay .bar > i { position:absolute; left:0; top:0; bottom:0; width:0%; background: var(--accent); }
    .overlay .muted { color: var(--muted); font-size:.9rem; }
    .ui-on .overlay { display:block; }
    .immersive .topbar { display: none; }
    .immersive .app { grid-template-rows: 0 0 1fr; }
    .font-kr-serif   { --font: "Noto Serif KR","Nanum Myeongjo","Gowun Batang","Song Myung","Iowan Old Style","Palatino Linotype","Book Antiqua",Palatino,serif; }
    .font-kr-sans    { --font: "Noto Sans KR","Pretendard","Spoqa Han Sans Neo","Inter","Helvetica Neue",Arial,sans-serif; }
    .font-kr-dodum   { --font: "Gowun Dodum","Noto Sans KR","Pretendard","Inter","Helvetica Neue",Arial,sans-serif; }
    .toast { position: fixed; right: 10px; bottom: 12px; background: #1b1b1bcc; color: #fff; padding: .5rem .7rem; border-radius: 10px; font-size: .9rem; z-index: 10000; display: none; }


    /* v4.3.2 — enhanced paper texture controls */
    .page::after{
      background-position: var(--paperTexPosX) var(--paperTexPosY);
      transform: rotate(var(--paperTexRotate));
      filter: var(--paperTexFilter);
      transform-origin: center;
    }
    /* second overlay above paper, useful for fibers/dots */
    .page::before{
      content:""; position:absolute; inset:0; border-radius: inherit; pointer-events:none;
      background-image: var(--paper2Tex);
      background-size: var(--paper2TexSize);
      background-repeat: var(--paper2TexRepeat);
      opacity: var(--paper2TexOpacity);
      mix-blend-mode: var(--paper2TexBlend);
      background-position: var(--paper2TexPosX) var(--paper2TexPosY);
      transform: rotate(var(--paper2TexRotate));
      filter: var(--paper2TexFilter);
      transform-origin: center;
    }
    /* v4.2.0 additions kept */
    .content-inner hr { border: none; border-top: 1px solid #00000030; margin: .9rem 0; height: 0; }
    .content-inner hr::after { content: ""; }
    .immersive .viewer { padding: 0 max(0px, env(safe-area-inset-right)) max(6px, env(safe-area-inset-bottom)) max(0px, env(safe-area-inset-left)); }
    .immersive .stage { place-items: stretch; }
    .immersive .page { width: 100%; height: 100%; border-radius: 0; }

    /* Theme Builder dialog */
    dialog#themeDlg{
      border: 1px solid #0002;
      border-radius: 14px;
      padding: 0;
      max-width: min(920px, 96vw);
      width: 96vw;
      box-shadow: var(--shadow);
      color: var(--ink);
      background: color-mix(in srgb, var(--paper) 85%, #fff 15%);
    }
    .dlg-head{ display:flex; align-items:center; gap:.6rem; padding:.8rem 1rem; border-bottom:1px solid #0001; }
    .dlg-body{ display:grid; grid-template-columns: 1fr 1fr; gap:1rem; padding:1rem; }
    .dlg-foot{ display:flex; gap:.6rem; padding: .8rem 1rem; border-top:1px solid #0001; justify-content:flex-end; }
    .fld{ display:grid; gap:.35rem; }
    .fld label{ font-size:.9rem; color: var(--muted); }
    .row{ display:flex; gap:.6rem; align-items:center; flex-wrap:wrap; }
    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#00000010; border:1px solid #0001; padding:.05rem .35rem; border-radius:6px; font-size:.85rem; }
    .optgroup-title{ font-weight:700; color:var(--muted); margin-top:.6rem; }
    .small{ font-size:.9rem; color:var(--muted); }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="topbar">
      <div class="title">📖 Paged v4.3.0</div>
      <label>테마
        <select id="themeSel">
          <option value="sepia">세피아</option>
          <option value="paper">화이트(종이)</option>
          <option value="solar">솔라</option>
          <option value="slate">슬레이트</option>
          <option value="midnight">미드나이트</option>
          <optgroup label="커스텀" id="customThemeGroup"></optgroup>
        </select>
      </label>
      <button id="themeBuilderBtn">테마 만들기</button>
      <label>글꼴
        <select id="fontSel">
          <option value="serif">세리프(Noto/Nanum/Gowun)</option>
          <option value="sans">산세리프(Noto/Pretendard)</option>
          <option value="dodum">고운돋움 느낌</option>
        </select>
        <button id="addFontBtn">폰트 추가</button>
        <select id="userFontSel" title="업로드 폰트 선택">
          <option value="">업로드 폰트 없음</option>
        </select>
        <button id="delFontBtn" title="선택 폰트 삭제">삭제</button>
        <input id="fontUpload" type="file" accept=".ttf,.otf,.woff,.woff2" style="position:fixed;left:-9999px;width:1px;height:1px;opacity:0" >
      </label>
      <label>글자 <input id="sizeRange" type="range" min="16" max="26" step="1"></label>
      <label>줄간격 <input id="lhRange" type="range" min="1.4" max="2.3" step=".05"></label>
      <label>여백 <input id="padRange" type="range" min="10" max="36" step="1"></label>
      <label>상단여백 <input id="tpadRange" type="range" min="0" max="40" step="1"></label>
      <label>폭 <input id="maxwRange" type="range" min="420" max="980" step="10"></label>
      <label>읽기속도(자/분) <input id="speedRange" type="range" min="250" max="1200" step="10"></label>
      <label><input type="checkbox" id="frameBox"> 페이지 프레임</label>
      <input id="findBox" type="search" placeholder="검색…" />
      <button id="findPrev">↑</button>
      <button id="findNext">↓</button>
      <button id="toggleEditor">에디터 접기/펼치기</button>
      <button id="focusBtn">전체화면(몰입)</button>
      <label><input type="checkbox" id="leftHanded"> 왼손잡이</label>
      <div style="margin-left:auto;color:var(--muted);font-size:.95rem;" id="pageInfo">0 / 0</div>
    </div>

    <div class="editor-wrap" id="editor">
      <textarea id="inputText" placeholder="여기에 ChatGPT 답변을 붙여넣고 [변환 & 페이징]을 누르세요. Markdown(제목/목록/인용문/코드/표) 일부 지원. 이미지는 폭에 맞게 자동 조정됩니다."></textarea>
      <div class="editor-actions">
        <button class="primary" id="renderBtn">변환 & 페이징</button>
        <button id="sampleBtn">샘플</button>
        <button id="clipBtn">클립보드</button>
        <button id="clearBtn">지우기</button>
        <label><input type="checkbox" id="autoCollapse" checked> 변환 후 에디터 접기</label>
      </div>
    </div>

    <div class="viewer" id="viewer">
      <div class="stage" id="stage"></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <template id="pageTpl">
    <div class="page">
      <button class="navbtn left" aria-label="이전">←</button>
      <button class="navbtn right" aria-label="다음">→</button>
      <div class="overlay">
        <div class="row">
          <div class="bar"><i id="progressBar"></i></div>
          <span id="progressText">0%</span>
          <span class="muted">페이지 <b id="pageNum">1</b> / <b id="pageTotal">1</b></span>
          <span class="muted">남은시간 <b id="etaText">–</b></span>
        </div>
      </div>
      <div class="content"><div class="content-inner"></div></div>
      <div class="tap left" data-dir="-1" aria-label="이전"></div>
      <div class="tap right" data-dir="1" aria-label="다음"></div>
      <div class="tap center" aria-label="UI 토글"></div>
      <div class="frame"></div>
      <div class="hint">중앙 탭: UI 토글</div>
      <div class="footer"><span class="badge pageBadge"></span></div>
    </div>
  </template>

  <!-- Theme Builder dialog -->
  <dialog id="themeDlg">
    <form method="dialog">
      <div class="dlg-head">
        <strong>🎨 테마 만들기</strong>
        <span class="small">종이 질감/배경 질감, 색상 팔레트 커스터마이징</span>
        <span style="margin-left:auto"></span>
        <button value="close">닫기</button>
      </div>
      <div class="dlg-body">
        <section>
          <div class="fld">
            <label>테마 이름</label>
            <input id="thName" type="text" placeholder="예: 내 세피아 종이" required>
          </div>
          <div class="row" style="margin-top:.4rem">
            <div class="fld"><label>배경색(bg)</label><input id="thBg" type="color" value="#f3ead7"></div>
            <div class="fld"><label>종이색(paper)</label><input id="thPaper" type="color" value="#fcf7ec"></div>
            <div class="fld"><label>글자색(ink)</label><input id="thInk" type="color" value="#2a261f"></div>
            <div class="fld"><label>서브텍스트(muted)</label><input id="thMuted" type="color" value="#6f665a"></div>
            <div class="fld"><label>포인트(accent)</label><input id="thAccent" type="color" value="#a47a51"></div>
          </div>
          <p class="small">색상만 바꾸고 싶다면 이 섹션만 조정해도 충분합니다.</p>

          <div class="optgroup-title">커스텀 테마 저장/불러오기</div>
          <div class="row">
            <select id="thLoadSel" title="저장된 커스텀 테마"></select>
            <button type="button" id="thLoadBtn">불러오기</button>
            <button type="button" id="thSaveBtn" class="primary">저장</button>
            <button type="button" id="thDelBtn">삭제</button>
            <button type="button" id="thPreviewBtn">미리보기</button> <button type="button" id="thRandomBtn" title="무작위 설정">랜덤</button>
            <span class="small">※ 저장 후 상단 '테마' 셀렉트의 커스텀 섹션에 나타납니다.</span>
          </div>
        </section>

        <section>
          <div class="optgroup-title">종이 질감 (페이지 위)</div>
          <div class="row">
            <select id="paperTexSel" title="종이 질감 선택">
              <option value="">(없음)</option>
            </select>
            <button type="button" id="paperTexAddBtn">업로드</button>
            <button type="button" id="paperTexDelBtn">삭제</button>
            <input id="paperTexFile" type="file" accept="image/*" style="position:fixed;left:-9999px;width:1px;height:1px;opacity:0" >
          </div>
          <div class="row">
            <label>모드
              <select id="paperMode">
                <option value="tile">타일(repeat)</option>
                <option value="cover">덮기(cover)</option>
                <option value="contain">맞춤(contain)</option>
              </select>
            </label>
            <label>크기(px) <input id="paperSize" type="number" min="64" max="2048" step="16" value="600"></label>
            <label>불투명도 <input id="paperOpacity" type="range" min="0" max="1" step="0.01" value="0.14"></label>
            <label>블렌드
              <select id="paperBlend">
                <option>multiply</option>
                <option>overlay</option>
                <option>soft-light</option>
                <option>normal</option>
              </select>
            </label>
          </div>

          
          <div class="row">
            <label>회전(°) <input id="paperRotate" type="range" min="-180" max="180" step="1" value="0"></label>
            <label>X 위치(px) <input id="paperPosX" type="number" value="0"></label>
            <label>Y 위치(px) <input id="paperPosY" type="number" value="0"></label>
            <label>밝기(%) <input id="paperBright" type="number" min="20" max="200" step="1" value="100"></label>
            <label>대비(%) <input id="paperContrast" type="number" min="20" max="200" step="1" value="100"></label>
            <label>채도(%) <input id="paperSaturate" type="number" min="0" max="200" step="1" value="100"></label>
            <label>회색조(%) <input id="paperGray" type="number" min="0" max="100" step="1" value="0"></label>
            <label>블러(px) <input id="paperBlur" type="number" min="0" max="8" step="0.5" value="0"></label>
          </div>

          <div class="optgroup-title" style="margin-top:.8rem">추가 레이어 (섬유/점박이)</div>
          <div class="row">
            <select id="paper2TexSel" title="추가 레이어 질감 선택">
              <option value="">(없음)</option>
            </select>
            <button type="button" id="paper2TexDelBtn">삭제</button>
          </div>
          <div class="row">
            <label>모드
              <select id="paper2Mode">
                <option value="tile">타일(repeat)</option>
                <option value="cover">덮기(cover)</option>
                <option value="contain">맞춤(contain)</option>
              </select>
            </label>
            <label>크기(px) <input id="paper2Size" type="number" min="64" max="2048" step="16" value="600"></label>
            <label>불투명도 <input id="paper2Opacity" type="range" min="0" max="1" step="0.01" value="0.08"></label>
            <label>블렌드
              <select id="paper2Blend">
                <option>multiply</option>
                <option>overlay</option>
                <option>soft-light</option>
                <option>normal</option>
              </select>
            </label>
          </div>
          <div class="row">
            <label>회전(°) <input id="paper2Rotate" type="range" min="-180" max="180" step="1" value="0"></label>
            <label>X 위치(px) <input id="paper2PosX" type="number" value="0"></label>
            <label>Y 위치(px) <input id="paper2PosY" type="number" value="0"></label>
            <label>밝기(%) <input id="paper2Bright" type="number" min="20" max="200" step="1" value="100"></label>
            <label>대비(%) <input id="paper2Contrast" type="number" min="20" max="200" step="1" value="100"></label>
            <label>채도(%) <input id="paper2Saturate" type="number" min="0" max="200" step="1" value="100"></label>
            <label>회색조(%) <input id="paper2Gray" type="number" min="0" max="100" step="1" value="0"></label>
            <label>블러(px) <input id="paper2Blur" type="number" min="0" max="8" step="0.5" value="0"></label>
          </div>

          <div class="optgroup-title" style="margin-top:.8rem">배경 질감 (페이지 뒤)</div>
          <div class="row">
            <select id="bgTexSel" title="배경 질감 선택">
              <option value="">(없음)</option>
            </select>
            <button type="button" id="bgTexAddBtn">업로드</button>
            <button type="button" id="bgTexDelBtn">삭제</button>
            <input id="bgTexFile" type="file" accept="image/*" style="position:fixed;left:-9999px;width:1px;height:1px;opacity:0" >
          </div>
          <div class="row">
            <label>모드
              <select id="bgMode">
                <option value="tile">타일(repeat)</option>
                <option value="cover">덮기(cover)</option>
                <option value="contain">맞춤(contain)</option>
              </select>
            </label>
            <label>크기(px) <input id="bgSize" type="number" min="64" max="4096" step="16" value="800"></label>
            <label>불투명도 <input id="bgOpacity" type="range" min="0" max="1" step="0.01" value="0.08"></label>
            <label>블렌드
              <select id="bgBlend">
                <option>normal</option>
                <option>multiply</option>
                <option>overlay</option>
                <option>soft-light</option>
              </select>
            </label>
          </div>
        </section>
      </div>
      <div class="dlg-foot">
        <button value="close">닫기</button>
      </div>
    </form>
  </dialog>

  <script>
    const $ = (q, el=document) => el.querySelector(q);
    const $$ = (q, el=document) => [...el.querySelectorAll(q)];
    const htmlEl = document.documentElement;
    const app = $("#app");
    const viewer = $("#viewer");
    const stage = $("#stage");
    const editor = $("#editor");
    const toast = $("#toast");
    const showToast = (msg)=>{ try{ toast.textContent = msg; toast.style.display="block"; setTimeout(()=> toast.style.display="none", 1800); }catch(e){} };

    const safeStorage = (()=>{
      try{ const k="__t"; localStorage.setItem(k,"1"); localStorage.removeItem(k); return localStorage; }
      catch(e){ const mem=new Map(); return { getItem:k=>mem.has(k)?mem.get(k):null, setItem:(k,v)=>mem.set(k,String(v)), removeItem:k=>mem.delete(k) }; }
    })();

    const prefsKey   = "pagedV4_1_1.prefs";
    const contentKey = "pagedV4_1_1.lastInput";
    const htmlKey    = "pagedV4_1_1.lastHtml";
    const themesKey  = "pagedV4_3_0.customThemes";
    let prefs = {}; try{ prefs = JSON.parse(safeStorage.getItem(prefsKey)||"{}"); }catch(_){}

    const themeSel = $("#themeSel");
    const customGroup = $("#customThemeGroup");
    const fontSel  = $("#fontSel");
    if(prefs.theme) htmlEl.setAttribute("data-theme", prefs.theme); else htmlEl.setAttribute("data-theme","sepia");
    document.body.classList.toggle("font-kr-sans", prefs.font==="sans");
    document.body.classList.toggle("font-kr-dodum", prefs.font==="dodum");
    themeSel.value = htmlEl.getAttribute("data-theme");
    fontSel.value = prefs.font || "serif";

    const sizeRange = $("#sizeRange");
    const lhRange   = $("#lhRange");
    const padRange  = $("#padRange");
    const tpadRange = $("#tpadRange");
    const maxwRange = $("#maxwRange");
    const speedRange= $("#speedRange");
    const toggleEditorBtn = $("#toggleEditor");
    const focusBtn = $("#focusBtn");
    const leftHanded = $("#leftHanded");
    const frameBox = $("#frameBox");
    const findBox = $("#findBox");

    // --- v4.3.0: DB (fonts + textures) ---
    function openDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open("PagedReaderDB", 2); // bump to v2: add textures store
        req.onupgradeneeded = ()=>{
          const db = req.result;
          if(!db.objectStoreNames.contains("fonts")){
            db.createObjectStore("fonts", { keyPath: "name" });
          }
          if(!db.objectStoreNames.contains("textures")){
            db.createObjectStore("textures", { keyPath: "name" });
          }
        };
        req.onsuccess = ()=> resolve(req.result);
        req.onerror = ()=> reject(req.error);
      });
    }
    const dbReady = openDB();

    // fonts
    async function dbGetAllFonts(){
      const db = await dbReady;
      return new Promise((resolve, reject)=>{
        const tx = db.transaction("fonts", "readonly");
        const st = tx.objectStore("fonts");
        const rq = st.getAll();
        rq.onsuccess = ()=> resolve(rq.result || []);
        rq.onerror = ()=> reject(rq.error);
      });
    }
    async function dbSaveFont(name, buf, meta){
      const db = await dbReady;
      return new Promise((resolve, reject)=>{
        const tx = db.transaction("fonts", "readwrite");
        tx.objectStore("fonts").put({ name, data: buf, meta: meta||{} });
        tx.oncomplete = ()=> resolve(true);
        tx.onerror = ()=> reject(tx.error);
      });
    }
    async function dbDeleteFont(name){
      const db = await dbReady;
      return new Promise((resolve, reject)=>{
        const tx = db.transaction("fonts", "readwrite");
        tx.objectStore("fonts").delete(name);
        tx.oncomplete = ()=> resolve(true);
        tx.onerror = ()=> reject(tx.error);
      });
    }

    // textures
    async function dbGetAllTextures(){
      const db = await dbReady;
      return new Promise((resolve, reject)=>{
        const tx = db.transaction("textures", "readonly");
        const st = tx.objectStore("textures");
        const rq = st.getAll();
        rq.onsuccess = ()=> resolve(rq.result || []);
        rq.onerror = ()=> reject(rq.error);
      });
    }
    async function dbSaveTexture(name, buf, meta){
      const db = await dbReady;
      return new Promise((resolve, reject)=>{
        const tx = db.transaction("textures", "readwrite");
        tx.objectStore("textures").put({ name, data: buf, meta: meta||{} });
        tx.oncomplete = ()=> resolve(true);
        tx.onerror = ()=> reject(tx.error);
      });
    }
    async function dbDeleteTexture(name){
      const db = await dbReady;
      return new Promise((resolve, reject)=>{
        const tx = db.transaction("textures", "readwrite");
        tx.objectStore("textures").delete(name);
        tx.oncomplete = ()=> resolve(true);
        tx.onerror = ()=> reject(tx.error);
      });
    }

    // font UI
    const userFontSel = $("#userFontSel");
    const addFontBtn  = $("#addFontBtn");
    const delFontBtn  = $("#delFontBtn");
    const fontUpload  = $("#fontUpload");

    async function registerFontRecord(rec){
      try{
        const ff = new FontFace(rec.name, rec.data);
        await ff.load();
        document.fonts.add(ff);
        return true;
      }catch(e){
        console.error("Font load failed:", e);
        showToast("폰트 로드 실패: " + (e?.message || e));
        return false;
      }
    }
    function applyUserFont(name){
      try{
        document.body.classList.remove("font-kr-sans","font-kr-dodum");
        htmlEl.style.setProperty("--font", `"${name}","Noto Sans KR","Pretendard","Inter","Helvetica Neue",Arial,sans-serif`);
        prefs.userFont = name; savePrefs(); repaginate();
      }catch(e){ console.warn(e); }
    }
    async function initFonts(){
      try{
        const list = await dbGetAllFonts();
        if(userFontSel){
          userFontSel.innerHTML = '<option value="">업로드 폰트 없음</option>' + list.map(x=>`<option value="${x.name}">${x.name}</option>`).join("");
        }
        for(const rec of list){ await registerFontRecord(rec); }
        if(prefs.userFont && list.find(x=>x.name===prefs.userFont)){
          if(userFontSel){ userFontSel.value = prefs.userFont; }
          applyUserFont(prefs.userFont);
        }
      }catch(e){ console.warn("initFonts error", e); }
    }
    if(addFontBtn && fontUpload){
      addFontBtn.addEventListener("click", async ()=>{ const f = await tryShowOpenFilePicker({types:[{description:"Fonts", accept:{"font/*":[".ttf",".otf",".woff",".woff2"]}}]}); if(f){ const dt=new DataTransfer(); dt.items.add(f); fontUpload.files = dt.files; fontUpload.dispatchEvent(new Event("change")); } else { fontUpload.click(); } });
      fontUpload.addEventListener("change", async (e)=>{
        const f = e.target.files && e.target.files[0];
        if(!f) return;
        const buf = await f.arrayBuffer();
        let name = f.name.replace(/\.(ttf|otf|woff2?|TTF|OTF|WOFF2?)$/,"");
        const exist = userFontSel ? [...userFontSel.options].map(o=>o.value) : [];
        let base = name, i=2;
        while(exist.includes(name)){ name = base + " (" + (i++) + ")"; }
        await dbSaveFont(name, buf, { ext: f.name.split(".").pop() });
        const ok = await registerFontRecord({ name, data: buf });
        if(ok){
          if(userFontSel){
            const opt = document.createElement("option"); opt.value = name; opt.textContent = name; userFontSel.appendChild(opt);
            userFontSel.value = name;
          }
          applyUserFont(name);
          showToast("폰트 저장 완료");
        }
        e.target.value = "";
      });
    }
    if(delFontBtn && userFontSel){
      delFontBtn.addEventListener("click", async ()=>{
        const name = userFontSel.value;
        if(!name){ showToast("삭제할 업로드 폰트를 선택하세요"); return; }
        await dbDeleteFont(name);
        const opt = [...userFontSel.options].find(o=>o.value===name); if(opt) opt.remove();
        if(prefs.userFont===name){ htmlEl.style.removeProperty("--font"); prefs.userFont=null; savePrefs(); repaginate(); }
        showToast("폰트 삭제 완료");
      });
      userFontSel.addEventListener("change", (e)=>{
        const name = e.target.value;
        if(name){ applyUserFont(name); }
        else { htmlEl.style.removeProperty("--font"); prefs.userFont=null; savePrefs(); repaginate(); }
      });
    }

    // texture UI/logic
    const themeDlg = $("#themeDlg");
    const themeBuilderBtn = $("#themeBuilderBtn");
    const thName = $("#thName");
    const thBg = $("#thBg");
    const thPaper = $("#thPaper");
    const thInk = $("#thInk");
    const thMuted = $("#thMuted");
    const thAccent = $("#thAccent");

    const thLoadSel = $("#thLoadSel");
    const thLoadBtn = $("#thLoadBtn");
    const thSaveBtn = $("#thSaveBtn");
    const thDelBtn = $("#thDelBtn");
    const thPreviewBtn = $("#thPreviewBtn");
    const thRandomBtn = $("#thRandomBtn");

    function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function hslToHex(h,s,l){
      // h:0-360, s/l:0-100
      s/=100; l/=100;
      const c=(1-Math.abs(2*l-1))*s;
      const x=c*(1-Math.abs(((h/60)%2)-1));
      const m=l-c/2;
      let [r,g,b]=[0,0,0];
      if(0<=h && h<60){ r=c; g=x; b=0; }
      else if(60<=h && h<120){ r=x; g=c; b=0; }
      else if(120<=h && h<180){ r=0; g=c; b=x; }
      else if(180<=h && h<240){ r=0; g=x; b=c; }
      else if(240<=h && h<300){ r=x; g=0; b=c; }
      else { r=c; g=0; b=x; }
      r = Math.round((r+m)*255); g = Math.round((g+m)*255); b = Math.round((b+m)*255);
      const toHex = n=> n.toString(16).padStart(2,"0");
      return "#" + toHex(r)+toHex(g)+toHex(b);
    }

    function genRandomTheme(){
      // Cohesive palette: choose base hue, then derive bg/paper/muted/ink/accent
      const H = randInt(0, 359);
      const paperL = randInt(94, 99);
      const bgL    = Math.max(90, paperL - randInt(3,8));
      const inkL   = randInt(10, 18);
      const mutedL = randInt(40, 55);
      const sat    = randInt(12, 32);
      const accentSat = randInt(45, 70);
      const accentL = randInt(40, 55);

      const colors = {
        bg:     hslToHex(H, sat, bgL),
        paper:  hslToHex((H+3)%360, sat-3, paperL),
        ink:    hslToHex((H+200)%360, Math.max(0,sat-8), inkL),
        muted:  hslToHex((H+200)%360, Math.max(0,sat-12), mutedL),
        accent: hslToHex((H+randInt(120,200))%360, accentSat, accentL)
      };

      function randomTex(kind){
        const sel = kind==="paper" ? paperTexSel : bgTexSel;
        const modeSel = kind==="paper" ? paperMode : bgMode;
        const sizeBox = kind==="paper" ? paperSize : bgSize;
        const opRange = kind==="paper" ? paperOpacity : bgOpacity;
        const blendSel= kind==="paper" ? paperBlend : bgBlend;
        const hasList = sel && sel.options && sel.options.length>1; // first option is (없음)
        if(hasList && Math.random() < 0.85){
          // Pick random texture except empty
          const pick = randInt(1, sel.options.length-1);
          sel.selectedIndex = pick;
        } else {
          sel.value = "";
        }
        const modes = ["tile","cover","contain"];
        modeSel.value = modes[randInt(0, modes.length-1)];
        // sizes: paper 400-900, bg 600-1600
        sizeBox.value = (kind==="paper" ? randInt(420, 980) : randInt(640, 2048));
        // opacity ranges
        opRange.value = (kind==="paper" ? (Math.random()*0.22 + 0.06) : (Math.random()*0.18 + 0.04)).toFixed(2);
        const blends = kind==="paper" ? ["multiply","overlay","soft-light","normal"] : ["normal","multiply","overlay","soft-light"];
        blendSel.value = blends[randInt(0, blends.length-1)];
      }

      // Write into form fields
      thBg.value    = colors.bg;
      thPaper.value = colors.paper;
      thInk.value   = colors.ink;
      thMuted.value = colors.muted;
      thAccent.value= colors.accent;

      randomTex("paper");
      randomTex("bg");
    }

    if(thRandomBtn){
      thRandomBtn.addEventListener("click", ()=>{
        genRandomTheme();
        const t = readFormTheme();
        applyCustomTheme(t);
        showToast("무작위 테마 미리보기 적용");
      });
    }


    const paperTexSel = $("#paperTexSel");
    const paperTexAddBtn = $("#paperTexAddBtn");
    const paperTexDelBtn = $("#paperTexDelBtn");
    const paperTexFile = $("#paperTexFile");
    const paperMode = $("#paperMode");
    const paperSize = $("#paperSize");
    const paperOpacity = $("#paperOpacity");
    const paperBlend = $("#paperBlend");

    const bgTexSel = $("#bgTexSel");
    const bgTexAddBtn = $("#bgTexAddBtn");
    const bgTexDelBtn = $("#bgTexDelBtn");
    const bgTexFile = $("#bgTexFile");
    const bgMode = $("#bgMode");
    const bgSize = $("#bgSize");
    const bgOpacity = $("#bgOpacity");
    const bgBlend = $("#bgBlend");

    let textureList = []; // {name, data:ArrayBuffer, meta}
    const textureURLCache = new Map(); // name -> objectURL

    async function initTexturesUI(){
      try{
        textureList = await dbGetAllTextures();
        const opts = ['<option value="">(없음)</option>'].concat(textureList.map(t=>`<option value="${t.name}">${t.name}</option>`)).join("");
        paperTexSel.innerHTML = opts;
        bgTexSel.innerHTML = opts;
      }catch(e){ console.warn(e); }
    }
    function getTextureURL(name){
      if(!name) return null;
      if(textureURLCache.has(name)) return textureURLCache.get(name);
      const rec = textureList.find(t=>t.name===name); if(!rec) return null;
      const blob = new Blob([rec.data], {type: rec.meta?.type || "image/*"});
      const url = URL.createObjectURL(blob);
      textureURLCache.set(name, url);
      return url;
    }
    async function addTextureFromFile(file, targetSel){
      const buf = await file.arrayBuffer();
      let name = file.name.replace(/\.(png|jpg|jpeg|webp|gif|bmp|PNG|JPG|JPEG|WEBP|GIF|BMP)$/,"");
      const exists = new Set(textureList.map(t=>t.name));
      let base=name, i=2; while(exists.has(name)){ name = base + " (" + (i++) + ")"; }
      await dbSaveTexture(name, buf, { type: file.type });
      textureList = await dbGetAllTextures();
      const opts = ['<option value="">(없음)</option>'].concat(textureList.map(t=>`<option value="${t.name}">${t.name}</option>`)).join("");
      paperTexSel.innerHTML = opts; bgTexSel.innerHTML = opts;
      targetSel.value = name;
      showToast("질감 저장 완료");
    }
    async function deleteTextureByName(name){
      if(!name) return;
      await dbDeleteTexture(name);
      textureURLCache.delete(name);
      textureList = await dbGetAllTextures();
      const opts = ['<option value="">(없음)</option>'].concat(textureList.map(t=>`<option value="${t.name}">${t.name}</option>`)).join("");
      paperTexSel.innerHTML = opts; bgTexSel.innerHTML = opts;
      showToast("질감 삭제 완료");
    }

    // themes storage
    function loadAllThemes(){
      try{ return JSON.parse(safeStorage.getItem(themesKey)||"[]"); }catch(_){ return []; }
    }
    function saveAllThemes(list){
      try{ safeStorage.setItem(themesKey, JSON.stringify(list)); }catch(_){}
    }
    function upsertTheme(obj){
      const list = loadAllThemes();
      const idx = list.findIndex(x=>x.name===obj.name);
      if(idx>=0) list[idx]=obj; else list.push(obj);
      saveAllThemes(list);
      populateCustomThemes();
    }
    function deleteTheme(name){
      const list = loadAllThemes().filter(x=>x.name!==name);
      saveAllThemes(list);
      populateCustomThemes();
    }
    function populateCustomThemes(){
      const list = loadAllThemes();
      thLoadSel.innerHTML = list.map(x=>`<option value="${x.name}">${x.name}</option>`).join("");
      // rebuild topbar custom options
      customGroup.innerHTML = list.map(x=>`<option value="custom:${x.name}">${x.name}</option>`).join("");
    }

    function getThemeByName(name){
      const list = loadAllThemes();
      return list.find(x=>x.name===name) || null;
    }

    function readFormTheme(){
      return {
        name: thName.value.trim() || "내 테마",
        colors: {
          bg: thBg.value, paper: thPaper.value, ink: thInk.value, muted: thMuted.value, accent: thAccent.value
        },
        paperTex: {
          name: paperTexSel.value || "",
          mode: paperMode.value,
          size: Number(paperSize.value)||600,
          opacity: Number(paperOpacity.value)||0,
          blend: paperBlend.value || "multiply"
        },
        bgTex: {
          name: bgTexSel.value || "",
          mode: bgMode.value,
          size: Number(bgSize.value)||800,
          opacity: Number(bgOpacity.value)||0,
          blend: bgBlend.value || "normal"
        }
      };
    }

    function applyCustomTheme(theme){
      // Mark data-theme=custom and set CSS vars inline (overrides built-ins)
      htmlEl.setAttribute("data-theme", "custom");
      htmlEl.style.setProperty("--bg", theme.colors.bg);
      htmlEl.style.setProperty("--paper", theme.colors.paper);
      htmlEl.style.setProperty("--ink", theme.colors.ink);
      htmlEl.style.setProperty("--muted", theme.colors.muted);
      htmlEl.style.setProperty("--accent", theme.colors.accent);

      function applyTex(kind, spec){
        const url = spec.name ? getTextureURL(spec.name) : null;
        const base = kind==="paper" ? "--paperTex" : "--bgTex";
        const baseSize = kind==="paper" ? "--paperTexSize" : "--bgTexSize";
        const baseRepeat = kind==="paper" ? "--paperTexRepeat" : "--bgTexRepeat";
        const baseOpacity = kind==="paper" ? "--paperTexOpacity" : "--bgTexOpacity";
        const baseBlend = kind==="paper" ? "--paperTexBlend" : "--bgTexBlend";
        htmlEl.style.setProperty(base, url ? `url("${url}")` : "none");
        if(spec.mode==="tile"){
          htmlEl.style.setProperty(baseSize, spec.size + "px");
          htmlEl.style.setProperty(baseRepeat, "repeat");
        } else {
          htmlEl.style.setProperty(baseSize, spec.mode); // cover/contain
          htmlEl.style.setProperty(baseRepeat, "no-repeat");
        }
        htmlEl.style.setProperty(baseOpacity, String(spec.opacity));
        htmlEl.style.setProperty(baseBlend, spec.blend);
      }
      applyTex("paper", theme.paperTex||{});
      applyTex("bg", theme.bgTex||{});

      // reflect in topbar 'themeSel'
      themeSel.value = "custom:" + theme.name;
      prefs.theme = "custom";
      prefs.customThemeName = theme.name;
      savePrefs();
      repaginate(); // remeasure since colors/overlays can affect text wraps sightly
    }

    function clearCustomOverrides(){
      // remove inline overrides so built-in themes take effect
      ["--bg","--paper","--ink","--muted","--accent",
       "--paperTex","--paperTexSize","--paperTexRepeat","--paperTexOpacity","--paperTexBlend",
       "--bgTex","--bgTexSize","--bgTexRepeat","--bgTexOpacity","--bgTexBlend"].forEach(v=> htmlEl.style.removeProperty(v));
    }

    // Populate initial custom themes & textures
    populateCustomThemes();
    initTexturesUI();

    // wire Theme Builder
    themeBuilderBtn.addEventListener("click", ()=>{
      // seed with current (custom or computed) colors
      const cs = getComputedStyle(htmlEl);
      thBg.value = rgbToHex(cs.getPropertyValue("--bg"));
      thPaper.value = rgbToHex(cs.getPropertyValue("--paper"));
      thInk.value = rgbToHex(cs.getPropertyValue("--ink"));
      thMuted.value = rgbToHex(cs.getPropertyValue("--muted"));
      thAccent.value = rgbToHex(cs.getPropertyValue("--accent"));
      thName.value = prefs.customThemeName || "";
      themeDlg.showModal();
    });

    thLoadBtn.addEventListener("click", ()=>{
      const name = thLoadSel.value; if(!name) return;
      const t = getThemeByName(name); if(!t) return;
      thName.value = t.name;
      thBg.value = t.colors.bg; thPaper.value=t.colors.paper; thInk.value=t.colors.ink; thMuted.value=t.colors.muted; thAccent.value=t.colors.accent;
      paperTexSel.value = t.paperTex?.name||""; paperMode.value=t.paperTex?.mode||"tile"; paperSize.value=t.paperTex?.size||600; paperOpacity.value=t.paperTex?.opacity??0.14; paperBlend.value=t.paperTex?.blend||"multiply";
      bgTexSel.value = t.bgTex?.name||""; bgMode.value=t.bgTex?.mode||"tile"; bgSize.value=t.bgTex?.size||800; bgOpacity.value=t.bgTex?.opacity??0.08; bgBlend.value=t.bgTex?.blend||"normal";
      showToast("불러왔어요");
    });
    thSaveBtn.addEventListener("click", ()=>{
      const t = readFormTheme();
      if(!t.name.trim()){ showToast("테마 이름을 입력하세요"); return; }
      upsertTheme(t);
      prefs.theme = "custom"; prefs.customThemeName = t.name; savePrefs();
      applyCustomTheme(t);
      showToast("저장 완료");
    });
    thDelBtn.addEventListener("click", ()=>{
      const name = thName.value.trim() || thLoadSel.value;
      if(!name){ showToast("삭제할 테마를 선택/입력하세요"); return; }
      deleteTheme(name);
      if(prefs.customThemeName===name){ prefs.customThemeName=null; prefs.theme="sepia"; htmlEl.setAttribute("data-theme","sepia"); clearCustomOverrides(); savePrefs(); themeSel.value="sepia"; repaginate(); }
      showToast("삭제 완료");
    });
    thPreviewBtn.addEventListener("click", ()=>{
      const t = readFormTheme(); applyCustomTheme(t); showToast("미리보기 적용");
    });

    // texture add/delete events
    paperTexAddBtn.addEventListener("click", async ()=>{ const f = await tryShowOpenFilePicker({types:[{description:"Images", accept:{"image/*":[".png",".jpg",".jpeg",".webp",".gif",".bmp"]}}]}); if(f){ const dt=new DataTransfer(); dt.items.add(f); paperTexFile.files = dt.files; paperTexFile.dispatchEvent(new Event("change")); } else { paperTexFile.click(); } });
    paperTexFile.addEventListener("change", async (e)=>{
      const f = e.target.files && e.target.files[0]; if(!f) return;
      await addTextureFromFile(f, paperTexSel);
      e.target.value = "";
    });
    paperTexDelBtn.addEventListener("click", async ()=>{
      const name = paperTexSel.value; if(!name){ showToast("삭제할 질감을 선택하세요"); return; }
      await deleteTextureByName(name);
    });
    bgTexAddBtn.addEventListener("click", async ()=>{ const f = await tryShowOpenFilePicker({types:[{description:"Images", accept:{"image/*":[".png",".jpg",".jpeg",".webp",".gif",".bmp"]}}]}); if(f){ const dt=new DataTransfer(); dt.items.add(f); bgTexFile.files = dt.files; bgTexFile.dispatchEvent(new Event("change")); } else { bgTexFile.click(); } });
    bgTexFile.addEventListener("change", async (e)=>{
      const f = e.target.files && e.target.files[0]; if(!f) return;
      await addTextureFromFile(f, bgTexSel);
      e.target.value = "";
    });
    bgTexDelBtn.addEventListener("click", async ()=>{
      const name = bgTexSel.value; if(!name){ showToast("삭제할 질감을 선택하세요"); return; }
      await deleteTextureByName(name);
    });

    // helpers
    function rgbToHex(rgb){
      // rgb(...) or #hex
      const s = (rgb||"").trim();
      if(!s) return "#000000";
      if(s.startsWith("#")) return s;
      const m = s.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      if(!m) return "#000000";
      const [r,g,b] = [m[1],m[2],m[3]].map(n=> Math.max(0, Math.min(255, parseInt(n,10)||0)));
      return "#" + [r,g,b].map(n=> n.toString(16).padStart(2,"0")).join("");
    }

    
    async function tryShowOpenFilePicker(options){
      if(window.showOpenFilePicker){
        try{
          const [hdl] = await window.showOpenFilePicker(Object.assign({multiple:false}, options||{}));
          return await hdl.getFile();
        }catch(e){ /* user cancel or unsupported */ }
      }
      return null;
    }
// built-in prefs wires
    sizeRange.value = prefs.size || 20;
    lhRange.value   = prefs.lh   || 1.8;
    padRange.value  = prefs.pad  || 18;
    tpadRange.value = prefs.tpad || 12;
    maxwRange.value = prefs.maxw || 900;
    speedRange.value= prefs.speed|| 600;
    frameBox.checked= !!prefs.frame;
    leftHanded.checked = !!prefs.leftHanded;
    htmlEl.style.setProperty("--size", sizeRange.value + "px");
    htmlEl.style.setProperty("--lh",   lhRange.value);
    htmlEl.style.setProperty("--pad",  padRange.value + "px");
    htmlEl.style.setProperty("--topPadExtra", tpadRange.value + "px");
    htmlEl.style.setProperty("--maxw", maxwRange.value + "px");
    htmlEl.style.setProperty("--frameOn", frameBox.checked ? 1 : 0);

    function savePrefs(){
      const p = {
        theme: htmlEl.getAttribute("data-theme"),
        customThemeName: prefs.customThemeName || null,
        font: fontSel.value,
        editorCollapsed: editor.classList.contains("collapsed"),
        size: sizeRange.value, lh: lhRange.value, pad: padRange.value, tpad: tpadRange.value,
        maxw: maxwRange.value, speed: speedRange.value, frame: frameBox.checked, leftHanded: leftHanded.checked,
        userFont: (userFontSel && userFontSel.value) || null
      };
      try{ safeStorage.setItem(prefsKey, JSON.stringify(p)); }catch(_){}
    }

    async function toggleFocus(){
      const entering = !(document.fullscreenElement && app.classList.contains("immersive"));
      try{
        if(entering){ app.classList.add("immersive"); if(app.requestFullscreen) await app.requestFullscreen(); }
        else { app.classList.remove("immersive"); if(document.fullscreenElement && document.exitFullscreen) await document.exitFullscreen(); }
      }catch(e){ if(!entering){ app.classList.remove("immersive"); } }
      resizeViewer(); repaginate(); savePrefs();
    }
    focusBtn.addEventListener("click", toggleFocus);
    document.addEventListener("fullscreenchange", ()=>{ if(!document.fullscreenElement){ app.classList.remove("immersive"); } resizeViewer(); repaginate(); });

    themeSel.addEventListener("change", (e)=>{
      const val = e.target.value || "sepia";
      if(val.startsWith("custom:")){
        const name = val.slice(7);
        const t = getThemeByName(name);
        if(t){ applyCustomTheme(t); }
        return;
      }
      // built-in
      htmlEl.setAttribute("data-theme", val);
      clearCustomOverrides();
      prefs.theme = val; prefs.customThemeName=null; savePrefs(); repaginate();
    });

    fontSel.addEventListener("change", (e)=>{
      document.body.classList.remove("font-kr-sans","font-kr-dodum");
      if(e.target.value==="sans") document.body.classList.add("font-kr-sans");
      if(e.target.value==="dodum") document.body.classList.add("font-kr-dodum");
      try{ if(userFontSel){ userFontSel.value=""; } htmlEl.style.removeProperty("--font"); prefs.userFont=null; }catch(_){ }
      savePrefs(); repaginate();
    });
    sizeRange.addEventListener("input", (e)=>{ htmlEl.style.setProperty("--size", e.target.value + "px"); savePrefs(); repaginate(); });
    lhRange.addEventListener("input",   (e)=>{ htmlEl.style.setProperty("--lh",   e.target.value);       savePrefs(); repaginate(); });
    padRange.addEventListener("input",  (e)=>{ htmlEl.style.setProperty("--pad",  e.target.value + "px"); savePrefs(); repaginate(); });
    tpadRange.addEventListener("input", (e)=>{ htmlEl.style.setProperty("--topPadExtra", e.target.value + "px"); savePrefs(); repaginate(); });
    maxwRange.addEventListener("input", (e)=>{ htmlEl.style.setProperty("--maxw", e.target.value + "px"); savePrefs(); repaginate(); });
    speedRange.addEventListener("input", ()=>{ updateOverlay(); savePrefs(); });
    toggleEditorBtn.addEventListener("click", ()=>{ editor.classList.toggle("collapsed"); resizeViewer(); repaginate(); savePrefs(); });
    leftHanded.addEventListener("change", ()=> savePrefs());
    frameBox.addEventListener("change", ()=>{ htmlEl.style.setProperty("--frameOn", frameBox.checked ? 1 : 0); savePrefs(); });

    function availViewportHeight(){ return (window.visualViewport ? window.visualViewport.height : window.innerHeight); }
    function resizeViewer(){
      const topH = app.classList.contains("immersive") ? 0 : document.querySelector(".topbar").getBoundingClientRect().height;
      const editH = editor.classList.contains("collapsed") ? 0 : editor.getBoundingClientRect().height;
      const h = Math.max(240, availViewportHeight() - topH - editH - 6);
      viewer.style.height = h + "px";
      return h;
    }
    let resizeTimer=null;
    window.addEventListener("resize", ()=>{ clearTimeout(resizeTimer); resizeTimer=setTimeout(()=>{ resizeViewer(); repaginate(); }, 80); }, {passive:true});
    window.addEventListener("orientationchange", ()=>{ setTimeout(()=>{ resizeViewer(); repaginate(); }, 120); });

    function escapeHtml(s){ return s.replaceAll(/&/g,"&amp;").replaceAll(/</g,"&lt;").replaceAll(/>/g,"&gt;"); }
    function parseMarkdown(src){
      if(!src) return "";
      const codes = [];
      src = src.replace(/```([\s\S]*?)```/g, (_,c)=>`@@CODE_${codes.push(c)-1}@@`);
      src = src.replaceAll("\r\n","\n");
      // Normalize literal <hr> or &lt;hr&gt; into actual horizontal rules
      src = src.replace(/&lt;\/?hr\s*\/?&gt;|<\s*hr\s*\/?>(?=\s|$)/gi, "\n<hr>\n");
      src = src.replace(/^(#{1,6})\s+(.+)$/gm, (_,h,t)=>`<h${h.length}>${escapeHtml(t)}</h${h.length}>`);
      src = src.replace(/^>\s?(.*)$/gm, (_,t)=>`<blockquote>${escapeHtml(t)}</blockquote>`);
      function listify(pattern, tag){
        const lines = src.split("\n"); let out=[], buf=[], inList=false;
        for(const line of lines){
          const m = line.match(pattern);
          if(m){ inList=true; buf.push(`<li>${escapeHtml(m[1])}</li>`); }
          else{ if(inList){ out.push(`<${tag}>${buf.join("")}</${tag}>`); buf=[]; inList=false; } out.push(line); }
        }
        if(inList) out.push(`<${tag}>${buf.join("")}</${tag}>`);
        src = out.join("\n");
      }
      listify(/^\s*[-*]\s+(.*)$/, "ul");
      listify(/^\s*\d+\.\s+(.*)$/, "ol");
      src = src.replace(/^\|(.+)\|\s*\n\|([:-\s|]+)\|\s*\n((?:\|.*\|\s*\n?)+)/gm, (m, head, sep, body)=>{
        const th = head.split("|").map(s=>`<th>${escapeHtml(s.trim())}</th>`).join("");
        const rows = body.trim().split("\n").map(line=>{
          const tds = line.replace(/^\||\|$/g,"").split("|").map(s=>`<td>${escapeHtml(s.trim())}</td>`).join("");
          return `<tr>${tds}</tr>`;
        }).join("");
        return `<table><thead><tr>${th}</tr></thead><tbody>${rows}</tbody></table>`;
      });
      src = src.replace(/^\s*(-{3,}|\*{3,})\s*$/gm, "<hr>");
      src = src.split(/\n{2,}/).map(blk=>{
        if(/^\s*</.test(blk)) return blk;
        if(!blk.trim()) return "";
        return `<p>${escapeHtml(blk.replace(/\n/g," "))}</p>`;
      }).join("\n");
      src = src.replace(/`([^`]+)`/g, (_,t)=>`<code>${escapeHtml(t)}</code>`)
               .replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>")
               .replace(/\*([^*]+)\*/g, "<em>$1</em>");
      src = src.replace(/@@CODE_(\d+)@@/g, (_,i)=>`<pre><code>${escapeHtml((codes[Number(i)]||"").trim())}</code></pre>`);
      return src;
    }

    let pages=[], current=0, lastHtml=null, matches=[], matchIndex=-1;
    let pageCharCounts=[], totalChars=0;
    function clearPages(){ pages.forEach(p=>p.remove()); pages=[]; current=0; pageCharCounts=[]; totalChars=0; }

    function newPage(measuring=false){
      const tpl = $("#pageTpl").content.firstElementChild.cloneNode(true);
      if(measuring) tpl.classList.add("measuring");
      stage.appendChild(tpl);
      pages.push(tpl);
      tpl.querySelector(".frame").style.display = (getComputedStyle(htmlEl).getPropertyValue("--frameOn").trim()=="1")? "" : "none";
      tpl.querySelector(".navbtn.left").addEventListener("click", ()=>go(-1));
      tpl.querySelector(".navbtn.right").addEventListener("click", ()=>go(1));
      const l = tpl.querySelector(".tap.left"), r = tpl.querySelector(".tap.right"), c = tpl.querySelector(".tap.center");
      function tapDir(dir){ const d = leftHanded.checked ? -dir : dir; go(d); if(navigator.vibrate) navigator.vibrate(8); }
      l.addEventListener("click", ()=>tapDir(-1));
      r.addEventListener("click", ()=>tapDir( 1));
      c.addEventListener("click", ()=> toggleOverlay());
      let sx=0, sy=0;
      tpl.addEventListener("touchstart",(e)=>{ const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true});
      tpl.addEventListener("touchend",(e)=>{ const t=e.changedTouches[0]; const dx=t.clientX-sx, dy=t.clientY-sy;
        if(Math.abs(dx)>40 && Math.abs(dy)<50){ tapDir(dx<0?1:-1); } }, {passive:true});
      return tpl;
    }

    function setCurrent(i){
      pages.forEach((p,idx)=>p.classList.toggle("current", idx===i));
      $("#pageInfo").textContent = `${i+1} / ${pages.length}`;
      updateOverlay();
    }

    function fitsContent(contentBox){
      const inner = contentBox.querySelector(".content-inner");
      return inner.scrollHeight <= contentBox.clientHeight;
    }

    function fitImage(img, contentBox){
      img.style.maxWidth = "100%"; img.style.height = "auto";
      img.style.maxHeight = Math.max(80, contentBox.clientHeight - 8) + "px";
    }

    function renderHtml(htmlContent){
      try{
        clearPages();
        const vh = resizeViewer();
        let page = newPage(true); page.style.height = vh + "px";
        let contentBox = page.querySelector(".content");
        let contentInner = page.querySelector(".content-inner");

        const scratch = document.createElement("div");
        scratch.style.position = "absolute"; scratch.style.left="-9999px"; scratch.style.top="0";
        const comp = getComputedStyle(page);
        const innerW = page.clientWidth - parseFloat(comp.paddingLeft) - parseFloat(comp.paddingRight);
        scratch.style.width = innerW + "px";
        scratch.innerHTML = htmlContent;
        document.body.appendChild(scratch);

        const nodes = [...scratch.childNodes];

        function startNewPage(){
          page = newPage(true); page.style.height = vh + "px";
          contentBox = page.querySelector(".content");
          contentInner = page.querySelector(".content-inner");
        }

        function splitTextBlock(node, prevContentBox){
          const text = node.textContent;
          const hasSpaces = /\s/.test(text);
          const units = hasSpaces ? text.split(/\s+/) : Array.from(text);
          let lo=1, hi=units.length, fit=0;
          function measure(cnt){
            const testWrap = document.createElement(node.tagName||"p");
            testWrap.textContent = units.slice(0,cnt).join(hasSpaces?" ":"");
            prevContentBox.querySelector(".content-inner").appendChild(testWrap);
            const ok = fitsContent(prevContentBox);
            testWrap.remove(); return ok;
          }
          while(lo<=hi){ const mid=(lo+hi)>>1; if(measure(mid)){ fit=mid; lo=mid+1; } else { hi=mid-1; } }
          const head = document.createElement(node.tagName||"p");
          head.textContent = units.slice(0, Math.max(1,fit)).join(hasSpaces?" ":"");
          prevContentBox.querySelector(".content-inner").appendChild(head);
          const rest = units.slice(Math.max(1,fit)).join(hasSpaces?" ":"");
          if(rest.trim()){
            const tail = document.createElement(node.tagName||"p"); tail.textContent = rest;
            startNewPage(); contentInner.appendChild(tail);
            if(!fitsContent(contentBox)){ const moved = contentInner.removeChild(tail); splitTextBlock(moved, contentBox); }
          }
        }

        function splitPreBlock(node, prevContentBox){
          const lines = node.textContent.split("\n");
          const pre1 = document.createElement("pre");
          const inner1 = prevContentBox.querySelector(".content-inner");
          inner1.appendChild(pre1);
          let cutIndex = lines.length;
          for(let i=0;i<lines.length;i++){
            pre1.textContent += (i? "\n":"") + lines[i];
            if(!fitsContent(prevContentBox)){ cutIndex = i; break; }
          }
          if(cutIndex < lines.length){
            const lastCut = pre1.textContent.lastIndexOf("\n");
            pre1.textContent = pre1.textContent.slice(0, Math.max(0,lastCut));
            startNewPage();
            const pre2 = document.createElement("pre");
            contentInner.appendChild(pre2);
            pre2.textContent = lines.slice(cutIndex).join("\n");
            if(!fitsContent(contentBox)){ const moved = contentInner.removeChild(pre2); splitPreBlock(moved, contentBox); }
          }
        }

        function splitList(node, prevContentBox, tag){
          const tmp = document.createElement(tag.toLowerCase());
          const inner1 = prevContentBox.querySelector(".content-inner");
          inner1.appendChild(tmp);
          const items = [...node.children];
          for(let i=0;i<items.length;i++){
            tmp.appendChild(items[i]);
            if(!fitsContent(prevContentBox)){
              const last = tmp.lastElementChild; if(last){ tmp.removeChild(last); }
              startNewPage();
              const nextList = document.createElement(tag.toLowerCase()); contentInner.appendChild(nextList);
              if(last) nextList.appendChild(last);
              for(let j=i+1;j<items.length;j++){
                nextList.appendChild(items[j]);
                if(!fitsContent(contentBox)){
                  const liLast = nextList.lastElementChild; if(liLast){ nextList.removeChild(liLast); }
                  startNewPage();
                  const nl = document.createElement(tag.toLowerCase()); contentInner.appendChild(nl);
                  if(liLast) nl.appendChild(liLast);
                }
              }
              break;
            }
          }
        }

        function splitTable(tableNode){
          const original = tableNode;
          const thead = original.querySelector("thead");
          const rows = [...(original.querySelector("tbody")?.rows || original.rows)];
          let i = 0;
          while(i < rows.length){
            const tbl = document.createElement("table");
            const tb = document.createElement("tbody");
            if(thead){ tbl.appendChild(thead.cloneNode(true)); }
            tbl.appendChild(tb);
            contentInner.appendChild(tbl);
            while(i < rows.length){
              tb.appendChild(rows[i]);
              if(!fitsContent(contentBox)){
                const last = tb.lastElementChild; if(last){ tb.removeChild(last); }
                startNewPage(); break;
              } else { i++; }
            }
          }
        }

        function splitNode(node){
          const tag = (node.tagName||"P").toUpperCase();
          if(["P","BLOCKQUOTE","LI","H4","H5","H6"].includes(tag)){
            splitTextBlock(node, contentBox);
          } else if(tag==="PRE"){
            splitPreBlock(node, contentBox);
          } else if(tag==="UL"||tag==="OL"){
            splitList(node, contentBox, tag);
          } else if(tag==="TABLE"){
            splitTable(node);
          } else if(tag==="IMG"){
            startNewPage(); contentInner.appendChild(node); fitImage(node, contentBox);
          } else {
            startNewPage(); contentInner.appendChild(node);
            if(!fitsContent(contentBox)){ splitTextBlock(node, contentBox); }
          }
        }

        function appendWithKeep(node){
          const tag = (node.tagName||"").toUpperCase();
          if(tag==="IMG"){
            contentInner.appendChild(node); fitImage(node, contentBox);
            if(!fitsContent(contentBox)){ contentInner.removeChild(node); startNewPage(); contentInner.appendChild(node); fitImage(node, contentBox); }
            return;
          }
          if(tag==="TABLE"){ splitTable(node); return; }
          if(tag==="H1"||tag==="H2"||tag==="H3"){
            const idx = nodes.indexOf(node);
            const nextNode = nodes[idx+1];
            contentInner.appendChild(node);
            if(!fitsContent(contentBox)){ contentInner.removeChild(node); startNewPage(); contentInner.appendChild(node); }
            if(nextNode && (nextNode.nodeType===1) && !/^H[1-3]$/.test((nextNode.tagName||"").toUpperCase())){
              contentInner.appendChild(nextNode);
              if(!fitsContent(contentBox)){
                contentInner.removeChild(nextNode); contentInner.removeChild(node);
                startNewPage(); contentInner.appendChild(node); contentInner.appendChild(nextNode);
                if(!fitsContent(contentBox)){ contentInner.removeChild(nextNode); splitNode(nextNode); }
              }
            }
            return;
          }
          // default
          contentInner.appendChild(node);
          if(!fitsContent(contentBox)){ contentInner.removeChild(node); splitNode(node); }
        }

        for(let i=0;i<nodes.length;i++){
          const node = nodes[i];
          let useNode = node;
          if(node.nodeType===3 && node.textContent.trim()){
            const p = document.createElement("p"); p.textContent = node.textContent; useNode = p;
          }
          appendWithKeep(useNode);
        }

        scratch.remove();
        pages.forEach(pg=> pg.classList.remove("measuring"));
        if(pages.length===0){ newPage(); }
        current = 0;
        pageCharCounts = pages.map(pg => (pg.querySelector(".content-inner").textContent || "").length);
        totalChars = pageCharCounts.reduce((a,b)=>a+b,0);
        setCurrent(0);
        lastHtml = htmlContent; try{ safeStorage.setItem(htmlKey, htmlContent); }catch(_){}
        $$(".content-inner img").forEach(img => { img.addEventListener("load", ()=>{ repaginateDebounced(); }, {once:true, passive:true}); });
        if(findBox.value) highlightAll(findBox.value);
        showToast("변환 완료!");
      }catch(err){ console.error(err); showToast("렌더 중 오류: " + (err?.message || err)); }
    }

    const repaginateDebounced = (()=>{ let t=null; return ()=>{ clearTimeout(t); t=setTimeout(()=>{ repaginate(); }, 120); }; })();
    function repaginate(){ const html = lastHtml || safeStorage.getItem(htmlKey); if(html){ renderHtml(html); } }

    function resetSearch(){ matches=[]; matchIndex=-1; $$(".mark-find").forEach(m=>m.replaceWith(document.createTextNode(m.textContent))); }
    function escReg(s){ return s.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&"); }
    function highlightAll(term){
      resetSearch(); if(!term.trim()) return;
      const re = new RegExp(escReg(term), "gi");
      pages.forEach(pg=>{
        const walker = document.createTreeWalker(pg.querySelector(".content-inner"), NodeFilter.SHOW_TEXT);
        const repl=[];
        while(walker.nextNode()){
          const node = walker.currentNode; if(!node.nodeValue.trim()) continue;
          if(re.test(node.nodeValue)){
            const span = document.createElement("span");
            span.innerHTML = node.nodeValue.replace(re, m=>`<mark class="mark-find">${m}</mark>`);
            repl.push([node, span]);
          }
          re.lastIndex=0;
        }
        repl.forEach(([n,span])=> n.parentNode.replaceChild(span, n));
      });
      matches = $$(".mark-find");
    }
    $("#findBox").addEventListener("input",(e)=>{ highlightAll(e.target.value||""); matchIndex=-1; });
    $("#findPrev").addEventListener("click", ()=>{ if(!matches.length) return; matchIndex = (matchIndex<=0? matches.length-1 : matchIndex-1); jumpToMatch(); });
    $("#findNext").addEventListener("click", ()=>{ if(!matches.length) return; matchIndex = (matchIndex+1) % matches.length; jumpToMatch(); });
    function jumpToMatch(){ const m = matches[matchIndex]; if(!m) return; const idx = pages.findIndex(pg=> pg.contains(m)); if(idx>=0){ current=idx; setCurrent(current); } m.scrollIntoView({block:"center"}); }

    function go(dir){
      if(!pages.length) return;
      const n = Math.max(0, Math.min(pages.length-1, current + (leftHanded.checked ? -dir : dir)));
      if(n!==current){ current = n; setCurrent(current); if(navigator.vibrate) navigator.vibrate(6); }
    }
    window.addEventListener("keydown",(e)=>{
      if(e.key==="ArrowRight"||e.key==="PageDown") go(1);
      if(e.key==="ArrowLeft"||e.key==="PageUp") go(-1);
      if(e.key==="Escape" && document.fullscreenElement){ document.exitFullscreen(); }
    });

    function toggleOverlay(force){
      const wantOn = typeof force==="boolean" ? force : !app.classList.contains("ui-on");
      app.classList.toggle("ui-on", wantOn);
      if(wantOn){ updateOverlay(); clearTimeout(toggleOverlay._t); toggleOverlay._t = setTimeout(()=>{ app.classList.remove("ui-on"); }, 3500); }
      else { clearTimeout(toggleOverlay._t); }
    }

    function updateOverlay(){
      const page = pages[current]; if(!page) return;
      const overlay = page.querySelector(".overlay");
      const bar = overlay.querySelector("#progressBar");
      const ptext = overlay.querySelector("#progressText");
      const eta = overlay.querySelector("#etaText");
      const numEl = overlay.querySelector("#pageNum");
      const totEl = overlay.querySelector("#pageTotal");
      let readChars = 0; for(let i=0;i<current;i++) readChars += (pageCharCounts[i]||0);
      const pct = totalChars ? Math.min(100, Math.round((readChars/totalChars)*100)) : 0;
      bar.style.width = pct + "%"; ptext.textContent = pct + "%";
      const cpm = Number(speedRange.value||600);
      const remain = Math.max(0, totalChars - readChars);
      const secs = Math.round((remain / Math.max(1,cpm)) * 60);
      eta.textContent = formatTime(secs);
      if(numEl) numEl.textContent = String(current+1);
      if(totEl) totEl.textContent = String(pages.length);
    }

    function formatTime(s){
      const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), sec = s%60;
      if(h>0) return `${h}시간 ${m}분`;
      if(m>0) return `${m}분 ${sec}초`;
      return `${sec}초`;
    }

    $("#clipBtn").addEventListener("click", async ()=>{
      try{ const t = await navigator.clipboard.readText(); $("#inputText").value = t; showToast("클립보드에서 붙여넣었어요"); }
      catch(e){ showToast("클립보드 접근 불가. 수동으로 붙여넣어 주세요."); }
    });

    $("#renderBtn").addEventListener("click", ()=>{
      try{
        const src = $("#inputText").value.trim();
        if(!src){ showToast("먼저 텍스트를 붙여넣어 주세요."); return; }
        try{ safeStorage.setItem(contentKey, src); }catch(_){}
        const html = parseMarkdown(src); renderHtml(html);
        if($("#autoCollapse").checked){ editor.classList.add("collapsed"); resizeViewer(); repaginate(); savePrefs(); }
      }catch(err){ console.error(err); showToast("변환 중 오류: " + (err?.message || err)); }
    });
    $("#clearBtn").addEventListener("click", ()=>{
      $("#inputText").value=""; resetSearch(); clearPages(); $("#pageInfo").textContent="0 / 0";
      try{ safeStorage.removeItem(contentKey); safeStorage.removeItem(htmlKey); }catch(_){}
      showToast("초기화 완료");
    });
    $("#sampleBtn").addEventListener("click", ()=>{
      $("#inputText").value = `# v4.3.0 패치 (Theme Builder)
- 커스텀 테마 생성/저장/삭제
- 종이 질감/배경 질감 업로드 & 적용 (IndexedDB)
- 커스텀 테마는 상단 '테마' 셀렉트의 커스텀 섹션으로 바로 접근 가능

| 항목 | 값 | 비고 |
|:--|:--:|--:|
| 샘플 | 123 | 오른쪽 정렬 |
| 긴문장테스트 | 예 | 예 |

${"문단 ".repeat(200)}`;
      showToast("샘플 텍스트가 채워졌어요");
    });

    (async function init(){
      resizeViewer();
      await initFonts();
      try{
        const saved = safeStorage.getItem(contentKey);
        const savedHtml = safeStorage.getItem(htmlKey);
        if(saved){ $("#inputText").value = saved; }
        if(savedHtml){ renderHtml(savedHtml); editor.classList.add("collapsed"); }
      }catch(_){}
      setTimeout(()=>{ const h=$(".page.current .hint"); if(h){ h.style.display="block"; setTimeout(()=> h.style.display="none", 1500); } }, 300);
      if('serviceWorker' in navigator){ navigator.serviceWorker.register('reader-sw.js').catch(_=>{}); }

      // if last used was custom, re-apply it
      if(prefs.theme==="custom" && prefs.customThemeName){
        const t = getThemeByName(prefs.customThemeName);
        if(t){ applyCustomTheme(t); }
      }
    })();
  
// === v4.3.2 Paper Texture Plus — extensions ===
(function(){
  // safely get element by id
  const $id = (x)=> document.getElementById(x);

  // new controls
  const paperRotate   = $id("paperRotate");
  const paperPosX     = $id("paperPosX");
  const paperPosY     = $id("paperPosY");
  const paperBright   = $id("paperBright");
  const paperContrast = $id("paperContrast");
  const paperSaturate = $id("paperSaturate");
  const paperGray     = $id("paperGray");
  const paperBlur     = $id("paperBlur");

  const paper2TexSel  = $id("paper2TexSel");
  const paper2TexDelBtn = $id("paper2TexDelBtn");
  const paper2Mode    = $id("paper2Mode");
  const paper2Size    = $id("paper2Size");
  const paper2Opacity = $id("paper2Opacity");
  const paper2Blend   = $id("paper2Blend");
  const paper2Rotate  = $id("paper2Rotate");
  const paper2PosX    = $id("paper2PosX");
  const paper2PosY    = $id("paper2PosY");
  const paper2Bright  = $id("paper2Bright");
  const paper2Contrast= $id("paper2Contrast");
  const paper2Saturate= $id("paper2Saturate");
  const paper2Gray    = $id("paper2Gray");
  const paper2Blur    = $id("paper2Blur");

  // fill paper2 select with the same options as paperTexSel
  try{
    const opts = document.getElementById("paperTexSel").innerHTML;
    if(paper2TexSel && opts) paper2TexSel.innerHTML = opts;
  }catch(e){}

  if(paper2TexDelBtn && paper2TexSel){
    paper2TexDelBtn.addEventListener("click", async ()=>{
      const name = paper2TexSel.value;
      if(!name){ showToast && showToast("삭제할 질감을 선택하세요"); return; }
      try{ await deleteTextureByName(name); }catch(_){}
    });
  }

  // extend readFormTheme
  const _readFormTheme = readFormTheme;
  readFormTheme = function(){
    const base = _readFormTheme();
    base.paperFX = {
      rotate: Number(paperRotate?.value||0),
      posX: Number(paperPosX?.value||0),
      posY: Number(paperPosY?.value||0),
      brightness: Number(paperBright?.value||100),
      contrast: Number(paperContrast?.value||100),
      saturate: Number(paperSaturate?.value||100),
      grayscale: Number(paperGray?.value||0),
      blur: Number(paperBlur?.value||0),
    };
    base.paper2Tex = {
      name: paper2TexSel?.value||"",
      mode: paper2Mode?.value||"tile",
      size: Number(paper2Size?.value||600),
      opacity: Number(paper2Opacity?.value||0),
      blend: paper2Blend?.value||"multiply"
    };
    base.paper2FX = {
      rotate: Number(paper2Rotate?.value||0),
      posX: Number(paper2PosX?.value||0),
      posY: Number(paper2PosY?.value||0),
      brightness: Number(paper2Bright?.value||100),
      contrast: Number(paper2Contrast?.value||100),
      saturate: Number(paper2Saturate?.value||100),
      grayscale: Number(paper2Gray?.value||0),
      blur: Number(paper2Blur?.value||0),
    };
    return base;
  };

  function buildFilter(fx){
    const parts = [];
    parts.push(`brightness(${fx.brightness||100}%)`);
    parts.push(`contrast(${fx.contrast||100}%)`);
    parts.push(`saturate(${fx.saturate||100}%)`);
    if((fx.grayscale||0)>0) parts.push(`grayscale(${fx.grayscale||0}%)`);
    if((fx.blur||0)>0) parts.push(`blur(${fx.blur||0}px)`);
    return parts.join(" ");
  }

  // extend applyCustomTheme
  const _applyCustomTheme = applyCustomTheme;
  applyCustomTheme = function(theme){
    _applyCustomTheme(theme);
    try{
      const fx = theme.paperFX || {};
      htmlEl.style.setProperty("--paperTexPosX", (fx.posX||0)+"px");
      htmlEl.style.setProperty("--paperTexPosY", (fx.posY||0)+"px");
      htmlEl.style.setProperty("--paperTexRotate", (fx.rotate||0)+"deg");
      htmlEl.style.setProperty("--paperTexFilter", buildFilter(fx));
    }catch(e){}

    try{
      const spec = theme.paper2Tex || {};
      const fx2  = theme.paper2FX || {};
      const url = spec.name ? getTextureURL(spec.name) : null;
      htmlEl.style.setProperty("--paper2Tex", url ? `url("${url}")` : "none");
      if(spec.mode==="tile"){
        htmlEl.style.setProperty("--paper2TexSize", (spec.size||600) + "px");
        htmlEl.style.setProperty("--paper2TexRepeat","repeat");
      }else{
        htmlEl.style.setProperty("--paper2TexSize", spec.mode||"cover");
        htmlEl.style.setProperty("--paper2TexRepeat","no-repeat");
      }
      htmlEl.style.setProperty("--paper2TexOpacity", String(spec.opacity||0));
      htmlEl.style.setProperty("--paper2TexBlend", spec.blend||"multiply");
      htmlEl.style.setProperty("--paper2TexPosX", (fx2.posX||0)+"px");
      htmlEl.style.setProperty("--paper2TexPosY", (fx2.posY||0)+"px");
      htmlEl.style.setProperty("--paper2TexRotate", (fx2.rotate||0)+"deg");
      htmlEl.style.setProperty("--paper2TexFilter", buildFilter(fx2));
    }catch(e){ console.warn(e); }
  };

  // add a helper to populate controls when loading a saved theme
  function applyFXToInputs(fx, prefix="paper"){
    try{
      ($id(prefix==="paper"?"paperRotate":"paper2Rotate")||{}).value = fx.rotate ?? 0;
      ($id(prefix==="paper"?"paperPosX":"paper2PosX")||{}).value = fx.posX ?? 0;
      ($id(prefix==="paper"?"paperPosY":"paper2PosY")||{}).value = fx.posY ?? 0;
      ($id(prefix==="paper"?"paperBright":"paper2Bright")||{}).value = fx.brightness ?? 100;
      ($id(prefix==="paper"?"paperContrast":"paper2Contrast")||{}).value = fx.contrast ?? 100;
      ($id(prefix==="paper"?"paperSaturate":"paper2Saturate")||{}).value = fx.saturate ?? 100;
      ($id(prefix==="paper"?"paperGray":"paper2Gray")||{}).value = fx.grayscale ?? 0;
      ($id(prefix==="paper"?"paperBlur":"paper2Blur")||{}).value = fx.blur ?? 0;
    }catch(e){}
  }

  // add-on loader for our extra fields
  thLoadBtn && thLoadBtn.addEventListener("click", ()=>{
    try{
      const name = thLoadSel.value; if(!name) return;
      const t = getThemeByName(name); if(!t) return;
      // set selects for paper2
      if(paper2TexSel) paper2TexSel.value = t.paper2Tex?.name || "";
      if(paper2Mode) paper2Mode.value = t.paper2Tex?.mode || "tile";
      if(paper2Size) paper2Size.value = t.paper2Tex?.size ?? 600;
      if(paper2Opacity) paper2Opacity.value = t.paper2Tex?.opacity ?? 0.08;
      if(paper2Blend) paper2Blend.value = t.paper2Tex?.blend || "multiply";
      applyFXToInputs(t.paperFX||{}, "paper");
      applyFXToInputs(t.paper2FX||{}, "paper2");
    }catch(e){}
  });

  // extend randomizer a bit (gentle ranges)
  const _genRandomTheme = (typeof genRandomTheme==="function") ? genRandomTheme : null;
  if(_genRandomTheme){
    genRandomTheme = function(){
      _genRandomTheme();
      // apply subtle random FX
      if(paperRotate) paperRotate.value = String((Math.random()*6-3).toFixed(0));
      if(paperPosX)   paperPosX.value   = String(Math.round(Math.random()*40-20));
      if(paperPosY)   paperPosY.value   = String(Math.round(Math.random()*40-20));
      if(paperBright) paperBright.value = String(95 + Math.round(Math.random()*10)); // 95~105
      if(paperContrast) paperContrast.value = String(95 + Math.round(Math.random()*10));
      if(paperSaturate) paperSaturate.value = String(90 + Math.round(Math.random()*20));
      if(paperGray)   paperGray.value   = String(Math.round(Math.random()*6)); // 0~6%
      if(paperBlur)   paperBlur.value   = String(0);

      // 30% chance to enable paper2 with low opacity
      if(Math.random()<0.3 && paper2TexSel && paper2Opacity){
        if(paper2TexSel.options.length>1){
          paper2TexSel.selectedIndex = 1 + Math.floor(Math.random()*(paper2TexSel.options.length-1));
          paper2Opacity.value = String((Math.random()*0.12+0.04).toFixed(2));
        }
      }
    };
  }

  // quick re-preview when changing important sliders
  ["paperRotate","paperPosX","paperPosY","paperBright","paperContrast","paperSaturate","paperGray","paperBlur",
   "paper2Rotate","paper2PosX","paper2PosY","paper2Bright","paper2Contrast","paper2Saturate","paper2Gray","paper2Blur",
   "paper2Mode","paper2Size","paper2Opacity","paper2Blend","paper2TexSel"].forEach(id=>{
    const el = $id(id); if(el){
      el.addEventListener("input", ()=>{ try{ const t=readFormTheme(); applyCustomTheme(t); }catch(_){ } });
      el.addEventListener("change", ()=>{ try{ const t=readFormTheme(); applyCustomTheme(t); }catch(_){ } });
    }
  });

  // if textures were initialized earlier, mirror options now
  try{
    if(typeof textureList!=="undefined"){
      const opts = ['<option value="">(없음)</option>'].concat(textureList.map(t=>`<option value="${t.name}">${t.name}</option>`)).join("");
      if(paper2TexSel) paper2TexSel.innerHTML = opts;
    }
  }catch(e){}

})(); // end v4.3.2 patch

  </script>
</body>
</html>
